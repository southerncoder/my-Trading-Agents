import { BaseMessage } from '@langchain/core/messages';

/**
 * State for investment debate between bull and bear researchers
 */
export interface InvestDebateState {
  /** Bullish conversation history */
  bullHistory: string;
  /** Bearish conversation history */
  bearHistory: string;
  /** Overall conversation history */
  history: string;
  /** Latest response in the debate */
  currentResponse: string;
  /** Final judge decision */
  judgeDecision: string;
  /** Length of the current conversation */
  count: number;
}

/**
 * State for risk management team debate
 */
export interface RiskDebateState {
  /** Risky agent's conversation history */
  riskyHistory: string;
  /** Safe agent's conversation history */
  safeHistory: string;
  /** Neutral agent's conversation history */
  neutralHistory: string;
  /** Overall conversation history */
  history: string;
  /** Analyst that spoke last */
  latestSpeaker: string;
  /** Latest response by the risky analyst */
  currentRiskyResponse: string;
  /** Latest response by the safe analyst */
  currentSafeResponse: string;
  /** Latest response by the neutral analyst */
  currentNeutralResponse: string;
  /** Judge's final decision */
  judgeDecision: string;
  /** Length of the current conversation */
  count: number;
}

/**
 * Main agent state that tracks the entire trading analysis workflow
 */
export interface AgentState {
  /** Company that we are interested in trading */
  companyOfInterest: string;
  /** What date we are trading at */
  tradeDate: string;
  /** Agent that sent this message */
  sender: string;
  /** LangChain messages for conversation flow */
  messages: BaseMessage[];

  // Research step reports
  /** Report from the Market Analyst */
  marketReport: string;
  /** Report from the Social Media Analyst */
  sentimentReport: string;
  /** Report from the News Researcher of current world affairs */
  newsReport: string;
  /** Report from the Fundamentals Researcher */
  fundamentalsReport: string;

  // Researcher team discussion step
  /** Current state of the debate on if to invest or not */
  investmentDebateState: InvestDebateState;
  /** Plan generated by the Research Manager */
  investmentPlan: string;

  // Trading step
  /** Plan generated by the Trader */
  traderInvestmentPlan: string;

  // Risk management team discussion step
  /** Current state of the debate on evaluating risk */
  riskDebateState: RiskDebateState;
  /** Final decision made by the Risk Management team */
  finalTradeDecision: string;
}

/**
 * Initial state factory for creating new agent states
 */
export function createInitialAgentState(companyOfInterest: string, tradeDate: string): AgentState {
  return {
    companyOfInterest,
    tradeDate,
    sender: '',
    messages: [],
    marketReport: '',
    sentimentReport: '',
    newsReport: '',
    fundamentalsReport: '',
    investmentDebateState: {
      bullHistory: '',
      bearHistory: '',
      history: '',
      currentResponse: '',
      judgeDecision: '',
      count: 0,
    },
    investmentPlan: '',
    traderInvestmentPlan: '',
    riskDebateState: {
      riskyHistory: '',
      safeHistory: '',
      neutralHistory: '',
      history: '',
      latestSpeaker: '',
      currentRiskyResponse: '',
      currentSafeResponse: '',
      currentNeutralResponse: '',
      judgeDecision: '',
      count: 0,
    },
    finalTradeDecision: '',
  };
}

/**
 * Type guards for checking state completeness
 */
export class AgentStateHelpers {
  static hasAnalystReports(state: AgentState): boolean {
    return !!(
      state.marketReport &&
      state.sentimentReport &&
      state.newsReport &&
      state.fundamentalsReport
    );
  }

  static hasInvestmentDecision(state: AgentState): boolean {
    return !!(state.investmentDebateState.judgeDecision && state.investmentPlan);
  }

  static hasTraderPlan(state: AgentState): boolean {
    return !!state.traderInvestmentPlan;
  }

  static hasRiskDecision(state: AgentState): boolean {
    return !!state.riskDebateState.judgeDecision;
  }

  static hasFinalDecision(state: AgentState): boolean {
    return !!state.finalTradeDecision;
  }

  static isComplete(state: AgentState): boolean {
    return this.hasFinalDecision(state);
  }
}